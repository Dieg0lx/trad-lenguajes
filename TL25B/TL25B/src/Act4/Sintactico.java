
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Wed Oct 22 23:39:42 CST 2025
//----------------------------------------------------

package Act4;

import java_cup.runtime.*;
import java.io.*;
import java.util.ArrayList;
import java.util.List;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Wed Oct 22 23:39:42 CST 2025
  */
public class Sintactico extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public Sintactico() {super();}

  /** Constructor which sets the default scanner. */
  public Sintactico(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Sintactico(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\101\000\002\002\004\000\002\010\003\000\002\010" +
    "\004\000\002\011\003\000\002\011\003\000\002\011\003" +
    "\000\002\011\003\000\002\011\003\000\002\011\003\000" +
    "\002\011\003\000\002\011\006\000\002\011\006\000\002" +
    "\012\005\000\002\006\003\000\002\006\005\000\002\007" +
    "\003\000\002\007\005\000\002\003\005\000\002\003\005" +
    "\000\002\003\005\000\002\003\005\000\002\003\005\000" +
    "\002\003\005\000\002\003\005\000\002\003\005\000\002" +
    "\003\003\000\002\005\005\000\002\005\005\000\002\005" +
    "\003\000\002\004\003\000\002\004\003\000\002\004\003" +
    "\000\002\004\003\000\002\004\003\000\002\004\003\000" +
    "\002\004\005\000\002\002\003\000\002\002\003\000\002" +
    "\002\003\000\002\002\003\000\002\002\003\000\002\002" +
    "\003\000\002\002\003\000\002\002\003\000\002\002\003" +
    "\000\002\002\003\000\002\002\003\000\002\002\003\000" +
    "\002\002\003\000\002\002\003\000\002\002\003\000\002" +
    "\002\003\000\002\026\002\000\002\013\012\000\002\027" +
    "\002\000\002\014\012\000\002\030\002\000\002\015\012" +
    "\000\002\031\002\000\002\032\002\000\002\016\015\000" +
    "\002\033\002\000\002\017\016\000\002\034\002\000\002" +
    "\020\011" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\200\000\056\004\036\005\011\006\013\007\012\010" +
    "\043\011\031\012\007\013\006\014\024\015\022\016\033" +
    "\017\026\020\037\021\027\022\004\023\041\024\017\026" +
    "\016\031\014\032\025\033\040\122\034\001\002\000\004" +
    "\122\uffcf\001\002\000\062\002\ufff9\004\ufff9\005\ufff9\006" +
    "\ufff9\007\ufff9\010\ufff9\011\ufff9\012\ufff9\013\ufff9\014\ufff9" +
    "\015\ufff9\016\ufff9\017\ufff9\020\ufff9\021\ufff9\022\ufff9\023" +
    "\ufff9\024\ufff9\026\ufff9\031\ufff9\032\ufff9\033\ufff9\112\ufff9" +
    "\122\ufff9\001\002\000\004\122\uffd6\001\002\000\004\122" +
    "\uffd7\001\002\000\060\002\202\004\036\005\011\006\013" +
    "\007\012\010\043\011\031\012\007\013\006\014\024\015" +
    "\022\016\033\017\026\020\037\021\027\022\004\023\041" +
    "\024\017\026\016\031\014\032\025\033\040\122\034\001" +
    "\002\000\004\122\uffdc\001\002\000\004\122\uffda\001\002" +
    "\000\004\122\uffdb\001\002\000\004\113\173\001\002\000" +
    "\062\002\ufffd\004\ufffd\005\ufffd\006\ufffd\007\ufffd\010\ufffd" +
    "\011\ufffd\012\ufffd\013\ufffd\014\ufffd\015\ufffd\016\ufffd\017" +
    "\ufffd\020\ufffd\021\ufffd\022\ufffd\023\ufffd\024\ufffd\026\ufffd" +
    "\031\ufffd\032\ufffd\033\ufffd\112\ufffd\122\ufffd\001\002\000" +
    "\004\113\165\001\002\000\004\113\156\001\002\000\062" +
    "\002\ufffb\004\ufffb\005\ufffb\006\ufffb\007\ufffb\010\ufffb\011" +
    "\ufffb\012\ufffb\013\ufffb\014\ufffb\015\ufffb\016\ufffb\017\ufffb" +
    "\020\ufffb\021\ufffb\022\ufffb\023\ufffb\024\ufffb\026\ufffb\031" +
    "\ufffb\032\ufffb\033\ufffb\112\ufffb\122\ufffb\001\002\000\004" +
    "\122\143\001\002\000\004\122\uffd4\001\002\000\062\002" +
    "\ufff8\004\ufff8\005\ufff8\006\ufff8\007\ufff8\010\ufff8\011\ufff8" +
    "\012\ufff8\013\ufff8\014\ufff8\015\ufff8\016\ufff8\017\ufff8\020" +
    "\ufff8\021\ufff8\022\ufff8\023\ufff8\024\ufff8\026\ufff8\031\ufff8" +
    "\032\ufff8\033\ufff8\112\ufff8\122\ufff8\001\002\000\004\122" +
    "\uffd5\001\002\000\004\111\uffc7\001\002\000\004\122\uffd2" +
    "\001\002\000\004\122\uffd0\001\002\000\062\002\000\004" +
    "\000\005\000\006\000\007\000\010\000\011\000\012\000" +
    "\013\000\014\000\015\000\016\000\017\000\020\000\021" +
    "\000\022\000\023\000\024\000\026\000\031\000\032\000" +
    "\033\000\112\000\122\000\001\002\000\004\122\uffd8\001" +
    "\002\000\062\002\ufffa\004\ufffa\005\ufffa\006\ufffa\007\ufffa" +
    "\010\ufffa\011\ufffa\012\ufffa\013\ufffa\014\ufffa\015\ufffa\016" +
    "\ufffa\017\ufffa\020\ufffa\021\ufffa\022\ufffa\023\ufffa\024\ufffa" +
    "\026\ufffa\031\ufffa\032\ufffa\033\ufffa\112\ufffa\122\ufffa\001" +
    "\002\000\004\122\uffd3\001\002\000\006\077\122\113\123" +
    "\001\002\000\062\002\ufffc\004\ufffc\005\ufffc\006\ufffc\007" +
    "\ufffc\010\ufffc\011\ufffc\012\ufffc\013\ufffc\014\ufffc\015\ufffc" +
    "\016\ufffc\017\ufffc\020\ufffc\021\ufffc\022\ufffc\023\ufffc\024" +
    "\ufffc\026\ufffc\031\ufffc\032\ufffc\033\ufffc\112\ufffc\122\ufffc" +
    "\001\002\000\004\122\uffdd\001\002\000\004\122\uffd1\001" +
    "\002\000\004\113\044\001\002\000\004\122\uffce\001\002" +
    "\000\062\002\ufffe\004\ufffe\005\ufffe\006\ufffe\007\ufffe\010" +
    "\ufffe\011\ufffe\012\ufffe\013\ufffe\014\ufffe\015\ufffe\016\ufffe" +
    "\017\ufffe\020\ufffe\021\ufffe\022\ufffe\023\ufffe\024\ufffe\026" +
    "\ufffe\031\ufffe\032\ufffe\033\ufffe\112\ufffe\122\ufffe\001\002" +
    "\000\004\122\uffd9\001\002\000\004\122\045\001\002\000" +
    "\012\077\120\114\ufff2\117\ufff2\120\ufff2\001\002\000\004" +
    "\117\047\001\002\000\020\064\051\065\055\066\057\067" +
    "\056\070\060\113\050\122\061\001\002\000\020\064\051" +
    "\065\055\066\057\067\056\070\060\113\050\122\061\001" +
    "\002\000\034\071\uffe1\072\uffe1\073\uffe1\074\uffe1\100\uffe1" +
    "\101\uffe1\102\uffe1\103\uffe1\104\uffe1\105\uffe1\114\uffe1\117" +
    "\uffe1\120\uffe1\001\002\000\034\071\uffe8\072\uffe8\073\074" +
    "\074\075\100\uffe8\101\uffe8\102\uffe8\103\uffe8\104\uffe8\105" +
    "\uffe8\114\uffe8\117\uffe8\120\uffe8\001\002\000\034\071\uffe5" +
    "\072\uffe5\073\uffe5\074\uffe5\100\uffe5\101\uffe5\102\uffe5\103" +
    "\uffe5\104\uffe5\105\uffe5\114\uffe5\117\uffe5\120\uffe5\001\002" +
    "\000\024\071\065\072\066\100\070\101\071\102\067\103" +
    "\062\104\063\105\072\117\064\001\002\000\034\071\uffe0" +
    "\072\uffe0\073\uffe0\074\uffe0\100\uffe0\101\uffe0\102\uffe0\103" +
    "\uffe0\104\uffe0\105\uffe0\114\uffe0\117\uffe0\120\uffe0\001\002" +
    "\000\034\071\uffe3\072\uffe3\073\uffe3\074\uffe3\100\uffe3\101" +
    "\uffe3\102\uffe3\103\uffe3\104\uffe3\105\uffe3\114\uffe3\117\uffe3" +
    "\120\uffe3\001\002\000\034\071\uffe2\072\uffe2\073\uffe2\074" +
    "\uffe2\100\uffe2\101\uffe2\102\uffe2\103\uffe2\104\uffe2\105\uffe2" +
    "\114\uffe2\117\uffe2\120\uffe2\001\002\000\034\071\uffe4\072" +
    "\uffe4\073\uffe4\074\uffe4\100\uffe4\101\uffe4\102\uffe4\103\uffe4" +
    "\104\uffe4\105\uffe4\114\uffe4\117\uffe4\120\uffe4\001\002\000" +
    "\034\071\uffdf\072\uffdf\073\uffdf\074\uffdf\100\uffdf\101\uffdf" +
    "\102\uffdf\103\uffdf\104\uffdf\105\uffdf\114\uffdf\117\uffdf\120" +
    "\uffdf\001\002\000\020\064\051\065\055\066\057\067\056" +
    "\070\060\113\050\122\061\001\002\000\020\064\051\065" +
    "\055\066\057\067\056\070\060\113\050\122\061\001\002" +
    "\000\004\122\045\001\002\000\020\064\051\065\055\066" +
    "\057\067\056\070\060\113\050\122\061\001\002\000\020" +
    "\064\051\065\055\066\057\067\056\070\060\113\050\122" +
    "\061\001\002\000\020\064\051\065\055\066\057\067\056" +
    "\070\060\113\050\122\061\001\002\000\020\064\051\065" +
    "\055\066\057\067\056\070\060\113\050\122\061\001\002" +
    "\000\020\064\051\065\055\066\057\067\056\070\060\113" +
    "\050\122\061\001\002\000\020\064\051\065\055\066\057" +
    "\067\056\070\060\113\050\122\061\001\002\000\034\071" +
    "\uffeb\072\uffeb\073\074\074\075\100\uffeb\101\uffeb\102\uffeb" +
    "\103\uffeb\104\uffeb\105\uffeb\114\uffeb\117\uffeb\120\uffeb\001" +
    "\002\000\020\064\051\065\055\066\057\067\056\070\060" +
    "\113\050\122\061\001\002\000\020\064\051\065\055\066" +
    "\057\067\056\070\060\113\050\122\061\001\002\000\034" +
    "\071\uffe6\072\uffe6\073\uffe6\074\uffe6\100\uffe6\101\uffe6\102" +
    "\uffe6\103\uffe6\104\uffe6\105\uffe6\114\uffe6\117\uffe6\120\uffe6" +
    "\001\002\000\034\071\uffe7\072\uffe7\073\uffe7\074\uffe7\100" +
    "\uffe7\101\uffe7\102\uffe7\103\uffe7\104\uffe7\105\uffe7\114\uffe7" +
    "\117\uffe7\120\uffe7\001\002\000\034\071\uffe9\072\uffe9\073" +
    "\074\074\075\100\uffe9\101\uffe9\102\uffe9\103\uffe9\104\uffe9" +
    "\105\uffe9\114\uffe9\117\uffe9\120\uffe9\001\002\000\034\071" +
    "\uffec\072\uffec\073\074\074\075\100\uffec\101\uffec\102\uffec" +
    "\103\uffec\104\uffec\105\uffec\114\uffec\117\uffec\120\uffec\001" +
    "\002\000\034\071\uffed\072\uffed\073\074\074\075\100\uffed" +
    "\101\uffed\102\uffed\103\uffed\104\uffed\105\uffed\114\uffed\117" +
    "\uffed\120\uffed\001\002\000\034\071\uffef\072\uffef\073\074" +
    "\074\075\100\uffef\101\uffef\102\uffef\103\uffef\104\uffef\105" +
    "\uffef\114\uffef\117\uffef\120\uffef\001\002\000\034\071\ufff0" +
    "\072\ufff0\073\074\074\075\100\ufff0\101\ufff0\102\ufff0\103" +
    "\ufff0\104\ufff0\105\ufff0\114\ufff0\117\ufff0\120\ufff0\001\002" +
    "\000\004\114\106\001\002\000\004\111\uffc4\001\002\000" +
    "\004\111\110\001\002\000\056\004\036\005\011\006\013" +
    "\007\012\010\043\011\031\012\007\013\006\014\024\015" +
    "\022\016\033\017\026\020\037\021\027\022\004\023\041" +
    "\024\017\026\016\031\014\032\025\033\040\122\034\001" +
    "\002\000\060\004\036\005\011\006\013\007\012\010\043" +
    "\011\031\012\007\013\006\014\024\015\022\016\033\017" +
    "\026\020\037\021\027\022\004\023\041\024\017\026\016" +
    "\031\014\032\025\033\040\112\112\122\034\001\002\000" +
    "\062\002\uffc3\004\uffc3\005\uffc3\006\uffc3\007\uffc3\010\uffc3" +
    "\011\uffc3\012\uffc3\013\uffc3\014\uffc3\015\uffc3\016\uffc3\017" +
    "\uffc3\020\uffc3\021\uffc3\022\uffc3\023\uffc3\024\uffc3\026\uffc3" +
    "\031\uffc3\032\uffc3\033\uffc3\112\uffc3\122\uffc3\001\002\000" +
    "\062\002\uffff\004\uffff\005\uffff\006\uffff\007\uffff\010\uffff" +
    "\011\uffff\012\uffff\013\uffff\014\uffff\015\uffff\016\uffff\017" +
    "\uffff\020\uffff\021\uffff\022\uffff\023\uffff\024\uffff\026\uffff" +
    "\031\uffff\032\uffff\033\uffff\112\uffff\122\uffff\001\002\000" +
    "\034\071\uffea\072\uffea\073\074\074\075\100\uffea\101\uffea" +
    "\102\uffea\103\uffea\104\uffea\105\uffea\114\uffea\117\uffea\120" +
    "\uffea\001\002\000\034\071\uffee\072\uffee\073\074\074\075" +
    "\100\uffee\101\uffee\102\uffee\103\uffee\104\uffee\105\uffee\114" +
    "\uffee\117\uffee\120\uffee\001\002\000\024\071\065\072\066" +
    "\100\070\101\071\102\067\103\062\104\063\105\072\114" +
    "\117\001\002\000\034\071\uffde\072\uffde\073\uffde\074\uffde" +
    "\100\uffde\101\uffde\102\uffde\103\uffde\104\uffde\105\uffde\114" +
    "\uffde\117\uffde\120\uffde\001\002\000\020\064\051\065\055" +
    "\066\057\067\056\070\060\113\050\122\061\001\002\000" +
    "\030\071\065\072\066\100\070\101\071\102\067\103\062" +
    "\104\063\105\072\114\ufff1\117\ufff1\120\ufff1\001\002\000" +
    "\020\064\051\065\055\066\057\067\056\070\060\113\050" +
    "\122\061\001\002\000\004\114\124\001\002\000\004\117" +
    "\125\001\002\000\062\002\ufff6\004\ufff6\005\ufff6\006\ufff6" +
    "\007\ufff6\010\ufff6\011\ufff6\012\ufff6\013\ufff6\014\ufff6\015" +
    "\ufff6\016\ufff6\017\ufff6\020\ufff6\021\ufff6\022\ufff6\023\ufff6" +
    "\024\ufff6\026\ufff6\031\ufff6\032\ufff6\033\ufff6\112\ufff6\122" +
    "\ufff6\001\002\000\024\071\065\072\066\100\070\101\071" +
    "\102\067\103\062\104\063\105\072\117\127\001\002\000" +
    "\062\002\ufff7\004\ufff7\005\ufff7\006\ufff7\007\ufff7\010\ufff7" +
    "\011\ufff7\012\ufff7\013\ufff7\014\ufff7\015\ufff7\016\ufff7\017" +
    "\ufff7\020\ufff7\021\ufff7\022\ufff7\023\ufff7\024\ufff7\026\ufff7" +
    "\031\ufff7\032\ufff7\033\ufff7\112\ufff7\122\ufff7\001\002\000" +
    "\004\111\131\001\002\000\056\004\036\005\011\006\013" +
    "\007\012\010\043\011\031\012\007\013\006\014\024\015" +
    "\022\016\033\017\026\020\037\021\027\022\004\023\041" +
    "\024\017\026\016\031\014\032\025\033\040\122\034\001" +
    "\002\000\060\004\036\005\011\006\013\007\012\010\043" +
    "\011\031\012\007\013\006\014\024\015\022\016\033\017" +
    "\026\020\037\021\027\022\004\023\041\024\017\026\016" +
    "\031\014\032\025\033\040\112\133\122\034\001\002\000" +
    "\004\031\uffc6\001\002\000\004\031\135\001\002\000\004" +
    "\113\136\001\002\000\020\064\051\065\055\066\057\067" +
    "\056\070\060\113\050\122\061\001\002\000\024\071\065" +
    "\072\066\100\070\101\071\102\067\103\062\104\063\105" +
    "\072\114\140\001\002\000\004\117\141\001\002\000\062" +
    "\002\uffc5\004\uffc5\005\uffc5\006\uffc5\007\uffc5\010\uffc5\011" +
    "\uffc5\012\uffc5\013\uffc5\014\uffc5\015\uffc5\016\uffc5\017\uffc5" +
    "\020\uffc5\021\uffc5\022\uffc5\023\uffc5\024\uffc5\026\uffc5\031" +
    "\uffc5\032\uffc5\033\uffc5\112\uffc5\122\uffc5\001\002\000\006" +
    "\117\154\120\153\001\002\000\012\077\120\113\145\117" +
    "\ufff2\120\ufff2\001\002\000\006\117\ufff4\120\ufff4\001\002" +
    "\000\004\114\146\001\002\000\004\111\uffcd\001\002\000" +
    "\004\111\150\001\002\000\056\004\036\005\011\006\013" +
    "\007\012\010\043\011\031\012\007\013\006\014\024\015" +
    "\022\016\033\017\026\020\037\021\027\022\004\023\041" +
    "\024\017\026\016\031\014\032\025\033\040\122\034\001" +
    "\002\000\060\004\036\005\011\006\013\007\012\010\043" +
    "\011\031\012\007\013\006\014\024\015\022\016\033\017" +
    "\026\020\037\021\027\022\004\023\041\024\017\026\016" +
    "\031\014\032\025\033\040\112\152\122\034\001\002\000" +
    "\062\002\uffcc\004\uffcc\005\uffcc\006\uffcc\007\uffcc\010\uffcc" +
    "\011\uffcc\012\uffcc\013\uffcc\014\uffcc\015\uffcc\016\uffcc\017" +
    "\uffcc\020\uffcc\021\uffcc\022\uffcc\023\uffcc\024\uffcc\026\uffcc" +
    "\031\uffcc\032\uffcc\033\uffcc\112\uffcc\122\uffcc\001\002\000" +
    "\004\122\045\001\002\000\062\002\ufff5\004\ufff5\005\ufff5" +
    "\006\ufff5\007\ufff5\010\ufff5\011\ufff5\012\ufff5\013\ufff5\014" +
    "\ufff5\015\ufff5\016\ufff5\017\ufff5\020\ufff5\021\ufff5\022\ufff5" +
    "\023\ufff5\024\ufff5\026\ufff5\031\ufff5\032\ufff5\033\ufff5\112" +
    "\ufff5\122\ufff5\001\002\000\006\117\ufff3\120\ufff3\001\002" +
    "\000\020\064\051\065\055\066\057\067\056\070\060\113" +
    "\050\122\061\001\002\000\024\071\065\072\066\100\070" +
    "\101\071\102\067\103\062\104\063\105\072\114\160\001" +
    "\002\000\004\111\uffcb\001\002\000\004\111\162\001\002" +
    "\000\056\004\036\005\011\006\013\007\012\010\043\011" +
    "\031\012\007\013\006\014\024\015\022\016\033\017\026" +
    "\020\037\021\027\022\004\023\041\024\017\026\016\031" +
    "\014\032\025\033\040\122\034\001\002\000\060\004\036" +
    "\005\011\006\013\007\012\010\043\011\031\012\007\013" +
    "\006\014\024\015\022\016\033\017\026\020\037\021\027" +
    "\022\004\023\041\024\017\026\016\031\014\032\025\033" +
    "\040\112\164\122\034\001\002\000\062\002\uffca\004\uffca" +
    "\005\uffca\006\uffca\007\uffca\010\uffca\011\uffca\012\uffca\013" +
    "\uffca\014\uffca\015\uffca\016\uffca\017\uffca\020\uffca\021\uffca" +
    "\022\uffca\023\uffca\024\uffca\026\uffca\031\uffca\032\uffca\033" +
    "\uffca\112\uffca\122\uffca\001\002\000\020\064\051\065\055" +
    "\066\057\067\056\070\060\113\050\122\061\001\002\000" +
    "\024\071\065\072\066\100\070\101\071\102\067\103\062" +
    "\104\063\105\072\114\167\001\002\000\004\111\uffc2\001" +
    "\002\000\004\111\171\001\002\000\004\112\172\001\002" +
    "\000\062\002\uffc1\004\uffc1\005\uffc1\006\uffc1\007\uffc1\010" +
    "\uffc1\011\uffc1\012\uffc1\013\uffc1\014\uffc1\015\uffc1\016\uffc1" +
    "\017\uffc1\020\uffc1\021\uffc1\022\uffc1\023\uffc1\024\uffc1\026" +
    "\uffc1\031\uffc1\032\uffc1\033\uffc1\112\uffc1\122\uffc1\001\002" +
    "\000\020\064\051\065\055\066\057\067\056\070\060\113" +
    "\050\122\061\001\002\000\024\071\065\072\066\100\070" +
    "\101\071\102\067\103\062\104\063\105\072\114\175\001" +
    "\002\000\004\111\uffc9\001\002\000\004\111\177\001\002" +
    "\000\056\004\036\005\011\006\013\007\012\010\043\011" +
    "\031\012\007\013\006\014\024\015\022\016\033\017\026" +
    "\020\037\021\027\022\004\023\041\024\017\026\016\031" +
    "\014\032\025\033\040\122\034\001\002\000\060\004\036" +
    "\005\011\006\013\007\012\010\043\011\031\012\007\013" +
    "\006\014\024\015\022\016\033\017\026\020\037\021\027" +
    "\022\004\023\041\024\017\026\016\031\014\032\025\033" +
    "\040\112\201\122\034\001\002\000\062\002\uffc8\004\uffc8" +
    "\005\uffc8\006\uffc8\007\uffc8\010\uffc8\011\uffc8\012\uffc8\013" +
    "\uffc8\014\uffc8\015\uffc8\016\uffc8\017\uffc8\020\uffc8\021\uffc8" +
    "\022\uffc8\023\uffc8\024\uffc8\026\uffc8\031\uffc8\032\uffc8\033" +
    "\uffc8\112\uffc8\122\uffc8\001\002\000\004\002\001\001\002" +
    "" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\200\000\026\002\020\010\007\011\027\012\041\013" +
    "\022\014\014\015\034\016\017\017\031\020\004\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\024\002\020\011\112\012\041\013\022" +
    "\014\014\015\034\016\017\017\031\020\004\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\006\141\007\143\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\031\127\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\007\045" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\003" +
    "\053\004\052\005\051\001\001\000\010\003\115\004\052" +
    "\005\051\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\004\052\005\114\001\001\000\006\004\052" +
    "\005\113\001\001\000\004\007\104\001\001\000\006\004" +
    "\052\005\103\001\001\000\006\004\052\005\102\001\001" +
    "\000\006\004\052\005\101\001\001\000\006\004\052\005" +
    "\100\001\001\000\006\004\052\005\077\001\001\000\006" +
    "\004\052\005\072\001\001\000\002\001\001\000\004\004" +
    "\076\001\001\000\004\004\075\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\033\106\001\001\000\002\001\001\000" +
    "\026\002\020\010\110\011\027\012\041\013\022\014\014" +
    "\015\034\016\017\017\031\020\004\001\001\000\024\002" +
    "\020\011\112\012\041\013\022\014\014\015\034\016\017" +
    "\017\031\020\004\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\003\120\004\052\005\051\001" +
    "\001\000\002\001\001\000\010\003\125\004\052\005\051" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\026\002\020\010\131\011\027\012\041\013\022\014" +
    "\014\015\034\016\017\017\031\020\004\001\001\000\024" +
    "\002\020\011\112\012\041\013\022\014\014\015\034\016" +
    "\017\017\031\020\004\001\001\000\004\032\133\001\001" +
    "\000\002\001\001\000\002\001\001\000\010\003\136\004" +
    "\052\005\051\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\026\146\001\001" +
    "\000\002\001\001\000\026\002\020\010\150\011\027\012" +
    "\041\013\022\014\014\015\034\016\017\017\031\020\004" +
    "\001\001\000\024\002\020\011\112\012\041\013\022\014" +
    "\014\015\034\016\017\017\031\020\004\001\001\000\002" +
    "\001\001\000\004\007\154\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\003\156\004\052\005\051\001\001" +
    "\000\002\001\001\000\004\027\160\001\001\000\002\001" +
    "\001\000\026\002\020\010\162\011\027\012\041\013\022" +
    "\014\014\015\034\016\017\017\031\020\004\001\001\000" +
    "\024\002\020\011\112\012\041\013\022\014\014\015\034" +
    "\016\017\017\031\020\004\001\001\000\002\001\001\000" +
    "\010\003\165\004\052\005\051\001\001\000\002\001\001" +
    "\000\004\034\167\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\003\173\004\052\005\051" +
    "\001\001\000\002\001\001\000\004\030\175\001\001\000" +
    "\002\001\001\000\026\002\020\010\177\011\027\012\041" +
    "\013\022\014\014\015\034\016\017\017\031\020\004\001" +
    "\001\000\024\002\020\011\112\012\041\013\022\014\014" +
    "\015\034\016\017\017\031\020\004\001\001\000\002\001" +
    "\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Sintactico$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Sintactico$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Sintactico$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    public TablaSimbolos tablaSimbolos = new TablaSimbolos();
    public List<String> erroresSemanticos = new ArrayList<>();

    public void reportarErrorSemantico(String mensaje, Symbol info) {
        String error = "Error Semantico: " + mensaje + " en la linea " + (info.left) + ", columna " + (info.right) + ".";
        if (!erroresSemanticos.contains(error)) {
            erroresSemanticos.add(error);
            System.err.println(error);
        }
    }

    public void report_fatal_error(String mensaje, Object informacion) { report_error(mensaje, informacion); }
    public void syntax_error(Symbol token_actual) {
        String mensajeError = "Error de sintaxis. ";
        if (token_actual.value != null) {
            mensajeError += "Token inesperado: '" + token_actual.value + "'.";
        }
        System.err.println(mensajeError + " Linea: " + (token_actual.left) + ", Columna: " + (token_actual.right));
    }
    public void report_error(String mensaje, Object informacion) {
        if (informacion instanceof Symbol) {
            Symbol s = ((Symbol) informacion);
            if (s.left >= 0 && s.right >= 0) {
                syntax_error(s);
                return;
            }
        }
        System.err.println(mensaje);
    }

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$Sintactico$actions {
  private final Sintactico parser;

  /** Constructor */
  CUP$Sintactico$actions(Sintactico parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$Sintactico$do_action(
    int                        CUP$Sintactico$act_num,
    java_cup.runtime.lr_parser CUP$Sintactico$parser,
    java.util.Stack            CUP$Sintactico$stack,
    int                        CUP$Sintactico$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Sintactico$result;

      /* select the action based on the action number */
      switch (CUP$Sintactico$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // sentencia_switch ::= SWITCH PAREN_APERTURA expresion PAREN_CIERRE NT$6 LLAVE_APERTURA LLAVE_CIERRE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_switch",14, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // NT$6 ::= 
            {
              Object RESULT =null;
 System.out.println("Sentencia Switch reconocida (sin analisis semantico aun)"); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$6",26, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // sentencia_for ::= FOR PAREN_APERTURA dec_var_item PUNTO_COMA expresion PUNTO_COMA dec_var_item PAREN_CIERRE NT$5 LLAVE_APERTURA sentencias LLAVE_CIERRE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
		 parser.tablaSimbolos.salirAlcance(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_for",13, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-11)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // NT$5 ::= 
            {
              Object RESULT =null;
 parser.tablaSimbolos.entrarAlcance(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$5",25, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // sentencia_do ::= DO NT$3 LLAVE_APERTURA sentencias LLAVE_CIERRE NT$4 WHILE PAREN_APERTURA expresion PAREN_CIERRE PUNTO_COMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).value;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_do",12, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-10)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // NT$4 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
 parser.tablaSimbolos.salirAlcance(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$4",24, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // NT$3 ::= 
            {
              Object RESULT =null;
 parser.tablaSimbolos.entrarAlcance(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$3",23, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // sentencia_while ::= WHILE PAREN_APERTURA expresion PAREN_CIERRE NT$2 LLAVE_APERTURA sentencias LLAVE_CIERRE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
		 parser.tablaSimbolos.salirAlcance(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_while",11, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // NT$2 ::= 
            {
              Object RESULT =null;
 parser.tablaSimbolos.entrarAlcance(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$2",22, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // sentencia_if ::= IF PAREN_APERTURA expresion PAREN_CIERRE NT$1 LLAVE_APERTURA sentencias LLAVE_CIERRE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
		 parser.tablaSimbolos.salirAlcance(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_if",10, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // NT$1 ::= 
            {
              Object RESULT =null;
 parser.tablaSimbolos.entrarAlcance(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$1",21, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // declaracion_metodo ::= tipo_dato IDENTIFICADOR PAREN_APERTURA PAREN_CIERRE NT$0 LLAVE_APERTURA sentencias LLAVE_CIERRE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
		 parser.tablaSimbolos.salirAlcance(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("declaracion_metodo",9, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // NT$0 ::= 
            {
              Object RESULT =null;

                       String t = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
                       Symbol id_symbol = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2));
                       parser.tablaSimbolos.insertar(id_symbol.value.toString(), t, id_symbol.left, id_symbol.right);
                       parser.tablaSimbolos.entrarAlcance(); 
                   
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$0",20, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // tipo_dato ::= VOID 
            {
              String RESULT =null;
		 RESULT = "VOID"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // tipo_dato ::= USHORT 
            {
              String RESULT =null;
		 RESULT = "USHORT"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // tipo_dato ::= ULONG 
            {
              String RESULT =null;
		 RESULT = "ULONG"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // tipo_dato ::= UINT 
            {
              String RESULT =null;
		 RESULT = "UINT"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // tipo_dato ::= STRING 
            {
              String RESULT =null;
		 RESULT = "STRING"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // tipo_dato ::= SHORT 
            {
              String RESULT =null;
		 RESULT = "SHORT"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // tipo_dato ::= SBYTE 
            {
              String RESULT =null;
		 RESULT = "SBYTE"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // tipo_dato ::= OBJECT 
            {
              String RESULT =null;
		 RESULT = "OBJECT"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // tipo_dato ::= LONG 
            {
              String RESULT =null;
		 RESULT = "LONG"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // tipo_dato ::= INT 
            {
              String RESULT =null;
		 RESULT = "INT"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // tipo_dato ::= FLOAT 
            {
              String RESULT =null;
		 RESULT = "FLOAT"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // tipo_dato ::= DOUBLE 
            {
              String RESULT =null;
		 RESULT = "DOUBLE"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // tipo_dato ::= DECIMAL 
            {
              String RESULT =null;
		 RESULT = "DECIMAL"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // tipo_dato ::= CHAR 
            {
              String RESULT =null;
		 RESULT = "CHAR"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // tipo_dato ::= BYTE 
            {
              String RESULT =null;
		 RESULT = "BYTE"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // tipo_dato ::= BOOL 
            {
              String RESULT =null;
		 RESULT = "BOOL"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // valor ::= PAREN_APERTURA expresion PAREN_CIERRE 
            {
              String RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		 RESULT = e; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("valor",2, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // valor ::= IDENTIFICADOR 
            {
              String RESULT =null;
		
           Symbol id_sym = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek());
           Simbolo s = parser.tablaSimbolos.buscar(id_sym.value.toString());
           if (s == null) {
               parser.reportarErrorSemantico("Identificador '" + id_sym.value + "' no ha sido declarado", id_sym);
               RESULT = "error_tipo";
           } else {
               RESULT = s.tipo;
           }
       
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("valor",2, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // valor ::= FALSE 
            {
              String RESULT =null;
		 RESULT = "BOOL"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("valor",2, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // valor ::= TRUE 
            {
              String RESULT =null;
		 RESULT = "BOOL"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("valor",2, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // valor ::= VALOR_CADENA 
            {
              String RESULT =null;
		 RESULT = "STRING"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("valor",2, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // valor ::= VALOR_FLOTANTE 
            {
              String RESULT =null;
		 RESULT = "FLOAT"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("valor",2, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // valor ::= VALOR_ENTERO 
            {
              String RESULT =null;
		 RESULT = "INT"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("valor",2, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // termino ::= valor 
            {
              String RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String v = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 RESULT = v; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("termino",3, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // termino ::= termino OPERADOR_DIVISION valor 
            {
              String RESULT =null;
		
                String t1 = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
                String v = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
                if ((t1.equals("INT") || t1.equals("FLOAT")) && (v.equals("INT") || v.equals("FLOAT"))) {
                    RESULT = "FLOAT";
                } else {
                    Symbol op_symbol = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1));
                    parser.reportarErrorSemantico("Operacion de division invalida entre los tipos " + t1 + " y " + v, op_symbol);
                    RESULT = "error_tipo";
                }
            
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("termino",3, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // termino ::= termino OPERADOR_MULTIPLICACION valor 
            {
              String RESULT =null;
		
                String t1 = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
                String v = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
                if ((t1.equals("INT") || t1.equals("FLOAT")) && (v.equals("INT") || v.equals("FLOAT"))) {
                    RESULT = t1.equals("FLOAT") || v.equals("FLOAT") ? "FLOAT" : "INT";
                } else {
                    Symbol op_symbol = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1));
                    parser.reportarErrorSemantico("Operacion de multiplicacion invalida entre los tipos " + t1 + " y " + v, op_symbol);
                    RESULT = "error_tipo";
                }
            
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("termino",3, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // expresion ::= termino 
            {
              String RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 RESULT = t; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",1, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // expresion ::= expresion DIFERENTE termino 
            {
              String RESULT =null;
		 RESULT = "BOOL"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",1, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // expresion ::= expresion MAYOR_IGUAL termino 
            {
              String RESULT =null;
		 RESULT = "BOOL"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",1, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // expresion ::= expresion MENOR_IGUAL termino 
            {
              String RESULT =null;
		 RESULT = "BOOL"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",1, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // expresion ::= expresion IGUAL_A termino 
            {
              String RESULT =null;
		 RESULT = "BOOL"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",1, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // expresion ::= expresion MAYOR termino 
            {
              String RESULT =null;
		 RESULT = "BOOL"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",1, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // expresion ::= expresion MENOR termino 
            {
              String RESULT =null;
		 RESULT = "BOOL"; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",1, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // expresion ::= expresion OPERADOR_RESTA termino 
            {
              String RESULT =null;
		
                String e1 = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
                String t = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
                if ((e1.equals("INT") || e1.equals("FLOAT")) && (t.equals("INT") || t.equals("FLOAT"))) {
                    RESULT = e1.equals("FLOAT") || t.equals("FLOAT") ? "FLOAT" : "INT";
                } else {
                    Symbol op_symbol = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1));
                    parser.reportarErrorSemantico("Operacion de resta invalida entre los tipos " + e1 + " y " + t, op_symbol);
                    RESULT = "error_tipo";
                }
            
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",1, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // expresion ::= expresion OPERADOR_SUMA termino 
            {
              String RESULT =null;
		
                String e1 = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
                String t = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
                if ((e1.equals("INT") || e1.equals("FLOAT")) && (t.equals("INT") || t.equals("FLOAT"))) {
                    RESULT = e1.equals("FLOAT") || t.equals("FLOAT") ? "FLOAT" : "INT";
                } else {
                    Symbol op_symbol = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1));
                    parser.reportarErrorSemantico("Operacion de suma invalida entre los tipos " + e1 + " y " + t, op_symbol);
                    RESULT = "error_tipo";
                }
            
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",1, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // dec_var_item ::= IDENTIFICADOR ASIGNACION expresion 
            {
              VarInfo RESULT =null;
		
                   Symbol id_sym = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2));
                   String e = (String) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
                   RESULT = new VarInfo(id_sym, e);
               
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("dec_var_item",5, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // dec_var_item ::= IDENTIFICADOR 
            {
              VarInfo RESULT =null;
		
                   Symbol id_sym = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek());
                   RESULT = new VarInfo(id_sym, null);
               
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("dec_var_item",5, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // dec_vars ::= dec_vars COMA dec_var_item 
            {
              ArrayList<VarInfo> RESULT =null;
		int lista_existenteleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int lista_existenteright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ArrayList<VarInfo> lista_existente = (ArrayList<VarInfo>)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int itemleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int itemright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		VarInfo item = (VarInfo)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
               lista_existente.add(item);
               RESULT = lista_existente;
           
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("dec_vars",4, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // dec_vars ::= dec_var_item 
            {
              ArrayList<VarInfo> RESULT =null;
		int itemleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int itemright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		VarInfo item = (VarInfo)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
               ArrayList<VarInfo> lista = new ArrayList<>();
               lista.add(item);
               RESULT = lista;
           
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("dec_vars",4, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // dec_variables ::= tipo_dato dec_vars PUNTO_COMA 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int lista_varsleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int lista_varsright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		ArrayList<VarInfo> lista_vars = (ArrayList<VarInfo>)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		
                    for (VarInfo info : lista_vars) {
                        String id = (String) info.symbol.value;
                        if (!parser.tablaSimbolos.insertar(id, t, info.symbol.left, info.symbol.right)) {
                            parser.reportarErrorSemantico("El identificador '" + id + "' ya fue declarado en este alcance", info.symbol);
                        }
                        if (info.tipoExpr != null) {
                            if (!t.equals(info.tipoExpr) && info.tipoExpr != "error_tipo") {
                                parser.reportarErrorSemantico("Tipos incompatibles. No se puede asignar " + info.tipoExpr + " a la nueva variable '" + id + "' de tipo " + t, info.symbol);
                            }
                        }
                    }
                
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("dec_variables",8, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // sentencia ::= IDENTIFICADOR PAREN_APERTURA PAREN_CIERRE PUNTO_COMA 
            {
              Object RESULT =null;
		
               Symbol id_sym = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3));
               Simbolo s = parser.tablaSimbolos.buscar(id_sym.value.toString());
               if (s == null) {
                   parser.reportarErrorSemantico("La funcin '" + id_sym.value + "' no ha sido declarada", id_sym);
               }
           
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",7, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // sentencia ::= IDENTIFICADOR ASIGNACION expresion PUNTO_COMA 
            {
              Object RESULT =null;
		
               Symbol id_sym = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3));
               String e = (String) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
               Simbolo s = parser.tablaSimbolos.buscar(id_sym.value.toString());
               if (s == null) {
                   parser.reportarErrorSemantico("La variable '" + id_sym.value + "' no ha sido declarada", id_sym);
               } else if (!s.tipo.equals(e) && e != "error_tipo") {
                   parser.reportarErrorSemantico("Tipos incompatibles. No se puede asignar " + e + " a la variable '" + id_sym.value + "' de tipo " + s.tipo, id_sym);
               }
           
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",7, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // sentencia ::= declaracion_metodo 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",7, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // sentencia ::= sentencia_switch 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",7, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // sentencia ::= sentencia_for 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",7, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // sentencia ::= sentencia_do 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",7, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // sentencia ::= sentencia_while 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",7, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // sentencia ::= sentencia_if 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",7, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // sentencia ::= dec_variables 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",7, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // sentencias ::= sentencias sentencia 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencias",6, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // sentencias ::= sentencia 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencias",6, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= sentencias EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		RESULT = start_val;
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Sintactico$parser.done_parsing();
          return CUP$Sintactico$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

