package Act4;

import java_cup.runtime.*;
import java.io.*;
import java.util.ArrayList;
import java.util.List;

parser code {:
    public TablaSimbolos tablaSimbolos = new TablaSimbolos();
    public List<String> erroresSemanticos = new ArrayList<>();
    public String tipoSwitchActual = null;

    public void reportarErrorSemantico(String mensaje, Symbol info) {
        String error = "Error Semantico: " + mensaje + " en la linea " + (info.left) + ", columna " + (info.right) + ".";
        if (!erroresSemanticos.contains(error)) {
            erroresSemanticos.add(error);
            System.err.println(error);
        }
    }

    public void report_fatal_error(String mensaje, Object informacion) { report_error(mensaje, informacion); }
    public void syntax_error(Symbol token_actual) {
        String mensajeError = "Error de sintaxis. ";
        if (token_actual.value != null) {
            mensajeError += "Token inesperado: '" + token_actual.value + "'.";
        }
        System.err.println(mensajeError + " Linea: " + (token_actual.left) + ", Columna: " + (token_actual.right));
    }
    public void report_error(String mensaje, Object informacion) {
        if (informacion instanceof Symbol) {
            Symbol s = ((Symbol) informacion);
            if (s.left >= 0 && s.right >= 0) {
                syntax_error(s);
                return;
            }
        }
        System.err.println(mensaje);
    }
:};

/* --- Terminales --- */
terminal BOOL, BYTE, CHAR, DECIMAL, DOUBLE, FLOAT, INT, LONG, OBJECT;
terminal SBYTE, SHORT, STRING, UINT, ULONG, USHORT, VOID;
terminal IF, ELSE, SWITCH, CASE, DEFAULT, WHILE, DO, FOR, FOREACH, CLASS;
terminal BREAK, CONTINUE, GOTO, RETURN, YIELD;
terminal PUBLIC, PRIVATE, PROTECTED, INTERNAL, ABSTRACT, ASYNC, CONST;
terminal EVENT, EXTERN, NEW, OVERRIDE, READONLY, SEALED, STATIC;
terminal UNSAFE, VIRTUAL, VOLATILE;
terminal TRUE, FALSE;
terminal VALOR_CADENA, VALOR_FLOTANTE, VALOR_ENTERO;
terminal OPERADOR_SUMA, OPERADOR_RESTA, OPERADOR_MULTIPLICACION, OPERADOR_DIVISION, OPERADOR_MODULO, UMENOS;
terminal ASIGNACION;
terminal IGUAL_A, DIFERENTE, MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL;
terminal AND, OR, NOT;
terminal LLAVE_APERTURA, LLAVE_CIERRE, PAREN_APERTURA, PAREN_CIERRE;
terminal CORCHETE_APERTURA, CORCHETE_CIERRE, PUNTO_COMA, COMA, PUNTO, DOS_PUNTOS;
terminal IDENTIFICADOR;

/* --- No Terminales --- */
non terminal String tipo_dato, expresion, valor, termino;
non terminal ArrayList<VarInfo> dec_vars;
non terminal VarInfo dec_var_item;
non terminal sentencias, sentencia, dec_variables, declaracion_metodo;
non terminal parametros;
non terminal Object sentencia_if, sentencia_while, sentencia_do, sentencia_for, sentencia_switch;
non terminal Object asignacion;
non terminal Object for_declaracion, for_init_opt, for_cond_opt, for_inc_opt;

non terminal Object switch_body;
non terminal Object switch_section_list;
non terminal Object switch_section;
non terminal Object switch_label_list;
non terminal Object switch_label;
non terminal Object parametros_opt, sentencias_opt;

/* --- Precedencia --- */
precedence left MAYOR, MENOR, IGUAL_A, MAYOR_IGUAL, MENOR_IGUAL, DIFERENTE;
precedence left OPERADOR_SUMA, OPERADOR_RESTA;
precedence left OPERADOR_MULTIPLICACION, OPERADOR_DIVISION;
precedence right UMENOS;

/* --- Gramática --- */
start with sentencias;

sentencias::= sentencia
            | sentencias sentencia
            ;

sentencia::= dec_variables
           | sentencia_if
           | sentencia_while
           | sentencia_do
           | sentencia_for
           | sentencia_switch
           | asignacion:a PUNTO_COMA
           {:
                VarInfo info = (VarInfo) a;  
                Symbol id_sym = info.symbol;
                String e = info.tipoExpr;
                Simbolo s = parser.tablaSimbolos.buscar(id_sym.value.toString());
                if (s == null) {
                    parser.reportarErrorSemantico("La variable '" + id_sym.value + "' no ha sido declarada", id_sym);
                } else if (!s.tipo.equals(e) && !e.equals("error_tipo")) {
                    parser.reportarErrorSemantico("Tipos incompatibles. No se puede asignar " + e + " a la variable '" + id_sym.value + "' de tipo " + s.tipo, id_sym);
                }
           :}
           | BREAK PUNTO_COMA
           | IDENTIFICADOR:id PAREN_APERTURA PAREN_CIERRE PUNTO_COMA
           {:
                Symbol id_sym = (Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3);
                Simbolo s = parser.tablaSimbolos.buscar(id_sym.value.toString());
                if (s == null) {
                    parser.reportarErrorSemantico("La función '" + id_sym.value + "' no ha sido declarada", id_sym);
                }
           :}
           | declaracion_metodo
           ;

asignacion ::= IDENTIFICADOR:id ASIGNACION expresion:e
{:
    Symbol id_sym = (Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2);
    String tipo_e = (String) e;
    RESULT = new VarInfo(id_sym, tipo_e);
:};

tipo_dato ::=
     INT       {: RESULT = "INT"; :}
   | FLOAT     {: RESULT = "FLOAT"; :}
   | DOUBLE    {: RESULT = "DOUBLE"; :}
   | STRING    {: RESULT = "STRING"; :}
   | BOOL      {: RESULT = "BOOL"; :}
   | CHAR      {: RESULT = "CHAR"; :}
   | LONG      {: RESULT = "LONG"; :}
   | DECIMAL   {: RESULT = "DECIMAL"; :}
   | SHORT     {: RESULT = "SHORT"; :}
   | BYTE      {: RESULT = "BYTE"; :}
   | VOID      {: RESULT = "VOID"; :}
   ;


for_declaracion ::= tipo_dato:t dec_vars:lista_vars
                 {:
                    for (VarInfo info : lista_vars) {
                        String id = (String) info.symbol.value;
                        if (!parser.tablaSimbolos.insertar(id, t, info.symbol.left, info.symbol.right)) {
                            parser.reportarErrorSemantico("El identificador '" + id + "' ya fue declarado en este alcance", info.symbol);
                        }
                        if (info.tipoExpr != null) {
                            if (!t.equals(info.tipoExpr) && !info.tipoExpr.equals("error_tipo")) {
                                parser.reportarErrorSemantico("Tipos incompatibles. No se puede asignar " + info.tipoExpr + " a la nueva variable '" + id + "' de tipo " + t, info.symbol);
                            }
                        }
                    }
                    RESULT = lista_vars;
                 :};

dec_variables::= for_declaracion PUNTO_COMA;
dec_vars::=dec_var_item:item
           {:
                ArrayList<VarInfo> lista = new ArrayList<>();
                lista.add(item);
                RESULT = lista;
           :}
           | dec_vars:lista_existente COMA dec_var_item:item
           {:
                lista_existente.add(item);
                RESULT = lista_existente;
           :}
           ;

dec_var_item ::=
    IDENTIFICADOR:id
    {:
        Symbol id_sym = (Symbol) CUP$Sintactico$stack.peek();
        RESULT = new VarInfo(id_sym, null);
    :}
  | IDENTIFICADOR:id ASIGNACION expresion:e
    {:
        Symbol id_sym = (Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2);
        String tipo_e = (String) e;
        RESULT = new VarInfo(id_sym, tipo_e);
    :};

expresion::= expresion:e1 OPERADOR_SUMA termino:t
             {:
                String tipo_e1 = (String)e1;
                String tipo_t = (String)t;
                Symbol op_symbol = (Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1); // Sigue usando la pila para obtener el Symbol del operador
                
                if ((tipo_e1.equals("INT") || tipo_e1.equals("FLOAT")) && (tipo_t.equals("INT") || tipo_t.equals("FLOAT"))) {
                    RESULT = tipo_e1.equals("FLOAT") || tipo_t.equals("FLOAT") ? "FLOAT" : "INT";
                } else {
                    parser.reportarErrorSemantico("Operacion de suma invalida entre los tipos " + tipo_e1 + " y " + tipo_t, op_symbol);
                    RESULT = "error_tipo";
                }
             :}
           | expresion:e1 OPERADOR_RESTA termino:t
             {:
                String tipo_e1 = (String)e1;
                String tipo_t = (String)t;
                Symbol op_symbol = (Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1);
                
                if ((tipo_e1.equals("INT") || tipo_e1.equals("FLOAT")) && (tipo_t.equals("INT") || tipo_t.equals("FLOAT"))) {
                    RESULT = tipo_e1.equals("FLOAT") || tipo_t.equals("FLOAT") ? "FLOAT" : "INT";
                } else {
                    parser.reportarErrorSemantico("Operacion de resta invalida entre los tipos " + tipo_e1 + " y " + tipo_t, op_symbol);
                    RESULT = "error_tipo";
                }
             :}
           | expresion MENOR termino         {: RESULT = "BOOL"; :}
           | expresion MAYOR termino         {: RESULT = "BOOL"; :}
           | expresion IGUAL_A termino       {: RESULT = "BOOL"; :}
           | expresion MENOR_IGUAL termino   {: RESULT = "BOOL"; :}
           | expresion MAYOR_IGUAL termino   {: RESULT = "BOOL"; :}
           | expresion DIFERENTE termino     {: RESULT = "BOOL"; :}
           | termino:t
             {: RESULT = t; :}
           ;

termino::= termino:t1 OPERADOR_MULTIPLICACION valor:v
           {:
                String tipo_t1 = (String)t1;
                String tipo_v = (String)v;
                Symbol op_symbol = (Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1);
                
                if ((tipo_t1.equals("INT") || tipo_t1.equals("FLOAT")) && (tipo_v.equals("INT") || tipo_v.equals("FLOAT"))) {
                    RESULT = tipo_t1.equals("FLOAT") || tipo_v.equals("FLOAT") ? "FLOAT" : "INT";
                } else {
                    parser.reportarErrorSemantico("Operacion de multiplicacion invalida entre los tipos " + tipo_t1 + " y " + tipo_v, op_symbol);
                    RESULT = "error_tipo";
                }
           :}
         | termino:t1 OPERADOR_DIVISION valor:v
           {:
                String tipo_t1 = (String)t1;
                String tipo_v = (String)v;
                Symbol op_symbol = (Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1);
                
                if ((tipo_t1.equals("INT") || tipo_t1.equals("FLOAT")) && (tipo_v.equals("INT") || tipo_v.equals("FLOAT"))) {
                    RESULT = "FLOAT";
                } else {
                    parser.reportarErrorSemantico("Operacion de division invalida entre los tipos " + tipo_t1 + " y " + tipo_v, op_symbol);
                    RESULT = "error_tipo";
                }
           :}
         | valor:v
           {: RESULT = v; :}
         ;

valor ::=
     VALOR_ENTERO      {: RESULT = "INT"; :}
   | VALOR_FLOTANTE    {: RESULT = "FLOAT"; :}
   | VALOR_CADENA      {: RESULT = "STRING"; :}
   | TRUE              {: RESULT = "BOOL"; :}
   | FALSE             {: RESULT = "BOOL"; :}
   | IDENTIFICADOR:id
     {:
          Symbol id_sym = (Symbol) CUP$Sintactico$stack.peek();
          Simbolo s = parser.tablaSimbolos.buscar(id_sym.value.toString());
          if (s == null) {
              parser.reportarErrorSemantico("Identificador '" + id_sym.value + "' no ha sido declarado", id_sym);
              RESULT = "error_tipo";
          } else {
              RESULT = s.tipo;
          }
      :}
    | PAREN_APERTURA expresion:e PAREN_CIERRE {: RESULT = e; :}
    ;

 sentencia_if::= IF PAREN_APERTURA expresion:e PAREN_CIERRE
             {:
                 String tipo = (String) e;
                 if (!tipo.equals("BOOL") && !tipo.equals("error_tipo")) {
                      Symbol sym_paren_cierre = (Symbol) CUP$Sintactico$stack.peek(); 
                      parser.reportarErrorSemantico("La condición del 'if' debe ser de tipo BOOL, no " + tipo, sym_paren_cierre);
                 }
                 parser.tablaSimbolos.entrarAlcance();
             :}
             LLAVE_APERTURA sentencias LLAVE_CIERRE
             {: parser.tablaSimbolos.salirAlcance(); :}
             ;

sentencia_while::= WHILE PAREN_APERTURA expresion:e PAREN_CIERRE
                 {:
                      String tipo = (String) e;
                      if (!tipo.equals("BOOL") && !tipo.equals("error_tipo")) {
                          Symbol sym_paren_cierre = (Symbol) CUP$Sintactico$stack.peek();
                          parser.reportarErrorSemantico("La condición del 'while' debe ser de tipo BOOL, no " + tipo, sym_paren_cierre);
                      }
                      parser.tablaSimbolos.entrarAlcance();
                      :}
                      LLAVE_APERTURA sentencias LLAVE_CIERRE
                      {: parser.tablaSimbolos.salirAlcance(); :}
                      ;

sentencia_do::= DO {: parser.tablaSimbolos.entrarAlcance(); :}
             LLAVE_APERTURA sentencias LLAVE_CIERRE
             {: parser.tablaSimbolos.salirAlcance(); :}
             WHILE PAREN_APERTURA expresion:e PAREN_CIERRE
             {:
                 String tipo = (String) e;
                 if (!tipo.equals("BOOL") && !tipo.equals("error_tipo")) {
                      Symbol sym_paren_cierre = (Symbol) CUP$Sintactico$stack.peek();
                      parser.reportarErrorSemantico("La condición del 'do-while' debe ser de tipo BOOL, no " + tipo, sym_paren_cierre);
                 }
             :}
             PUNTO_COMA;

for_init_opt::= for_declaracion:decl {: RESULT = decl; :}
               | asignacion:asig {: RESULT = asig; :}
               |                 {: RESULT = null; :}
               ;

for_cond_opt::= expresion:e {: RESULT = e; :}
               |             {: RESULT = "BOOL"; :}
               ;

for_inc_opt::= asignacion:a {: RESULT = a; :}
             |              {: RESULT = null; :}
             ;

sentencia_for::= FOR
    {: parser.tablaSimbolos.entrarAlcance(); :}
    PAREN_APERTURA
    for_init_opt:init
    PUNTO_COMA
    for_cond_opt:cond
    PUNTO_COMA
    for_inc_opt:inc
    PAREN_CIERRE
    LLAVE_APERTURA
        sentencias
    LLAVE_CIERRE
    {:
        if (cond != null && !cond.equals("BOOL") && !cond.equals("error_tipo")) {
            Symbol sym_punto_coma = (Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6);
            parser.reportarErrorSemantico("La condición del bucle 'for' debe ser de tipo BOOL, no " + cond, sym_punto_coma);
        }
        parser.tablaSimbolos.salirAlcance();
    :};

sentencia_switch::= SWITCH PAREN_APERTURA expresion:e PAREN_CIERRE
                     {:
                          String tipo = (String) e;
                          if (!tipo.equals("INT") && !tipo.equals("STRING") && !tipo.equals("CHAR") && !tipo.equals("error_tipo")) {
                              Symbol sym_paren_cierre = (Symbol) CUP$Sintactico$stack.peek();
                              parser.reportarErrorSemantico("El tipo " + tipo + " no es válido para una sentencia 'switch'", sym_paren_cierre);
                              parser.tipoSwitchActual = "error_tipo";
                          } else {
                              parser.tipoSwitchActual = tipo;
                          }
                          parser.tablaSimbolos.entrarAlcance();
                     :}
                     LLAVE_APERTURA
                     switch_body
                     LLAVE_CIERRE
                     {:
                          parser.tablaSimbolos.salirAlcance();
                          parser.tipoSwitchActual = null;
                     :};

/* --- GRAMÁTICA PARA EL CUERPO DEL SWITCH --- */

switch_body ::=
     switch_section_list
   | /* vacío */
   ;


switch_section_list::= switch_section
                     | switch_section_list switch_section
                     ;

switch_section::= switch_label_list sentencias
                 ;

switch_label_list::= switch_label
                    | switch_label_list switch_label
                    ;


switch_label::= CASE valor:v DOS_PUNTOS
                 {:
                    String tipoCase = (String) v;
                    if (parser.tipoSwitchActual != null && !parser.tipoSwitchActual.equals("error_tipo") && !tipoCase.equals("error_tipo")) {
                        if (!parser.tipoSwitchActual.equals(tipoCase)) {
                            Symbol sym_case = (Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2); 
                            parser.reportarErrorSemantico("Tipo de 'case' (" + tipoCase + ") incompatible con el tipo del 'switch' (" + parser.tipoSwitchActual + ")", sym_case);
                        }
                    }
                 :}
               | DEFAULT DOS_PUNTOS
               ;

declaracion_metodo ::= tipo_dato:ret IDENTIFICADOR:id PAREN_APERTURA parametros_opt PAREN_CIERRE
                      {:
                          Symbol symId = (Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3);
                          String nombreMetodo = symId.value.toString();

                          if (!parser.tablaSimbolos.insertar(nombreMetodo, ret, symId.left, symId.right)) {
                              parser.reportarErrorSemantico("El método '" + nombreMetodo + "' ya fue declarado", symId);
                          }

                          parser.tablaSimbolos.entrarAlcance();
                      :}
                      LLAVE_APERTURA
                      sentencias_opt
                      LLAVE_CIERRE
                      {:
                          parser.tablaSimbolos.salirAlcance();
                      :}
                      ;

parametros_opt ::= parametros
                 | /* vacío */ ;

parametros ::= tipo_dato:tipo IDENTIFICADOR:id
             {:
                Symbol id_sym = (Symbol) CUP$Sintactico$stack.peek();
                parser.tablaSimbolos.insertar(id_sym.value.toString(), tipo, id_sym.left, id_sym.right);
             :}
           | parametros COMA tipo_dato:tipo IDENTIFICADOR:id
             {:
                Symbol id_sym = (Symbol) CUP$Sintactico$stack.peek();
                parser.tablaSimbolos.insertar(id_sym.value.toString(), tipo, id_sym.left, id_sym.right);
             :}
             ;

sentencias_opt ::= sentencias
                 | /* vacío */ ;