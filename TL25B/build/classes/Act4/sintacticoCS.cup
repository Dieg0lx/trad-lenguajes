package Act4;

import java_cup.runtime.*;
import java.io.*;
import java.util.ArrayList;
import java.util.List;

parser code {:
    public TablaSimbolos tablaSimbolos = new TablaSimbolos();
    public List<String> erroresSemanticos = new ArrayList<>();

    public void reportarErrorSemantico(String mensaje, Symbol info) {
        String error = "Error Semantico: " + mensaje + " en la linea " + (info.left) + ", columna " + (info.right) + ".";
        if (!erroresSemanticos.contains(error)) {
            erroresSemanticos.add(error);
            System.err.println(error);
        }
    }

    public void report_fatal_error(String mensaje, Object informacion) { report_error(mensaje, informacion); }
    public void syntax_error(Symbol token_actual) {
        String mensajeError = "Error de sintaxis. ";
        if (token_actual.value != null) {
            mensajeError += "Token inesperado: '" + token_actual.value + "'.";
        }
        System.err.println(mensajeError + " Linea: " + (token_actual.left) + ", Columna: " + (token_actual.right));
    }
    public void report_error(String mensaje, Object informacion) {
        if (informacion instanceof Symbol) {
            Symbol s = ((Symbol) informacion);
            if (s.left >= 0 && s.right >= 0) {
                syntax_error(s);
                return;
            }
        }
        System.err.println(mensaje);
    }
:};

/* --- Terminales --- */
terminal BOOL, BYTE, CHAR, DECIMAL, DOUBLE, FLOAT, INT, LONG, OBJECT;
terminal SBYTE, SHORT, STRING, UINT, ULONG, USHORT, VOID;
terminal IF, ELSE, SWITCH, CASE, DEFAULT, WHILE, DO, FOR, FOREACH, CLASS;
terminal BREAK, CONTINUE, GOTO, RETURN, YIELD;
terminal PUBLIC, PRIVATE, PROTECTED, INTERNAL, ABSTRACT, ASYNC, CONST;
terminal EVENT, EXTERN, NEW, OVERRIDE, READONLY, SEALED, STATIC;
terminal UNSAFE, VIRTUAL, VOLATILE;
terminal TRUE, FALSE;
terminal VALOR_CADENA, VALOR_FLOTANTE, VALOR_ENTERO;
terminal OPERADOR_SUMA, OPERADOR_RESTA, OPERADOR_MULTIPLICACION, OPERADOR_DIVISION, OPERADOR_MODULO, UMENOS;
terminal ASIGNACION;
terminal IGUAL_A, DIFERENTE, MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL;
terminal AND, OR, NOT;
terminal LLAVE_APERTURA, LLAVE_CIERRE, PAREN_APERTURA, PAREN_CIERRE;
terminal CORCHETE_APERTURA, CORCHETE_CIERRE, PUNTO_COMA, COMA, PUNTO;
terminal IDENTIFICADOR;

/* --- No Terminales --- */
non terminal String tipo_dato, expresion, valor, termino;
non terminal ArrayList<VarInfo> dec_vars;
non terminal VarInfo dec_var_item;
non terminal sentencias, sentencia, dec_variables, declaracion_metodo;
non terminal Object sentencia_if, sentencia_while, sentencia_do, sentencia_for, sentencia_switch;
non terminal Object parametros, lista_parametros, parametro, cuerpo_clase, elemento_clase;

/* --- Precedencia --- */
precedence left MAYOR, MENOR, IGUAL_A, MAYOR_IGUAL, MENOR_IGUAL, DIFERENTE;
precedence left OPERADOR_SUMA, OPERADOR_RESTA;
precedence left OPERADOR_MULTIPLICACION, OPERADOR_DIVISION;
precedence right UMENOS;

/* --- Gramática --- */
start with sentencias;

sentencias::= sentencia
            | sentencias sentencia
            ;

sentencia::= dec_variables
           | sentencia_if
           | sentencia_while
           | sentencia_do
           | sentencia_for
           | sentencia_switch
           | declaracion_metodo
           | IDENTIFICADOR ASIGNACION expresion PUNTO_COMA
           {:
               Symbol id_sym = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3));
               String e = (String) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
               Simbolo s = parser.tablaSimbolos.buscar(id_sym.value.toString());
               if (s == null) {
                   parser.reportarErrorSemantico("La variable '" + id_sym.value + "' no ha sido declarada", id_sym);
               } else if (!s.tipo.equals(e) && e != "error_tipo") {
                   parser.reportarErrorSemantico("Tipos incompatibles. No se puede asignar " + e + " a la variable '" + id_sym.value + "' de tipo " + s.tipo, id_sym);
               }
           :}
           | IDENTIFICADOR PAREN_APERTURA PAREN_CIERRE PUNTO_COMA
           {:
               Symbol id_sym = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3));
               Simbolo s = parser.tablaSimbolos.buscar(id_sym.value.toString());
               if (s == null) {
                   parser.reportarErrorSemantico("La función '" + id_sym.value + "' no ha sido declarada", id_sym);
               }
           :}
           ;

dec_variables::= tipo_dato:t dec_vars:lista_vars PUNTO_COMA
                {:
                    for (VarInfo info : lista_vars) {
                        String id = (String) info.symbol.value;
                        if (!parser.tablaSimbolos.insertar(id, t, info.symbol.left, info.symbol.right)) {
                            parser.reportarErrorSemantico("El identificador '" + id + "' ya fue declarado en este alcance", info.symbol);
                        }
                        if (info.tipoExpr != null) {
                            if (!t.equals(info.tipoExpr) && info.tipoExpr != "error_tipo") {
                                parser.reportarErrorSemantico("Tipos incompatibles. No se puede asignar " + info.tipoExpr + " a la nueva variable '" + id + "' de tipo " + t, info.symbol);
                            }
                        }
                    }
                :}
                ;

dec_vars::= dec_var_item:item
           {:
               ArrayList<VarInfo> lista = new ArrayList<>();
               lista.add(item);
               RESULT = lista;
           :}
           | dec_vars:lista_existente COMA dec_var_item:item
           {:
               lista_existente.add(item);
               RESULT = lista_existente;
           :}
           ;

dec_var_item::= IDENTIFICADOR
               {:
                   Symbol id_sym = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek());
                   RESULT = new VarInfo(id_sym, null);
               :}
               | IDENTIFICADOR ASIGNACION expresion
               {:
                   Symbol id_sym = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2));
                   String e = (String) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
                   RESULT = new VarInfo(id_sym, e);
               :}
               ;

expresion::= expresion OPERADOR_SUMA termino
            {:
                String e1 = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
                String t = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
                if ((e1.equals("INT") || e1.equals("FLOAT")) && (t.equals("INT") || t.equals("FLOAT"))) {
                    RESULT = e1.equals("FLOAT") || t.equals("FLOAT") ? "FLOAT" : "INT";
                } else {
                    Symbol op_symbol = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1));
                    parser.reportarErrorSemantico("Operacion de suma invalida entre los tipos " + e1 + " y " + t, op_symbol);
                    RESULT = "error_tipo";
                }
            :}
           | expresion OPERADOR_RESTA termino
            {:
                String e1 = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
                String t = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
                if ((e1.equals("INT") || e1.equals("FLOAT")) && (t.equals("INT") || t.equals("FLOAT"))) {
                    RESULT = e1.equals("FLOAT") || t.equals("FLOAT") ? "FLOAT" : "INT";
                } else {
                    Symbol op_symbol = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1));
                    parser.reportarErrorSemantico("Operacion de resta invalida entre los tipos " + e1 + " y " + t, op_symbol);
                    RESULT = "error_tipo";
                }
            :}
           | expresion MENOR termino        {: RESULT = "BOOL"; :}
           | expresion MAYOR termino        {: RESULT = "BOOL"; :}
           | expresion IGUAL_A termino      {: RESULT = "BOOL"; :}
           | expresion MENOR_IGUAL termino  {: RESULT = "BOOL"; :}
           | expresion MAYOR_IGUAL termino  {: RESULT = "BOOL"; :}
           | expresion DIFERENTE termino    {: RESULT = "BOOL"; :}
           | termino:t
            {: RESULT = t; :}
           ;

termino::= termino OPERADOR_MULTIPLICACION valor
            {:
                String t1 = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
                String v = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
                if ((t1.equals("INT") || t1.equals("FLOAT")) && (v.equals("INT") || v.equals("FLOAT"))) {
                    RESULT = t1.equals("FLOAT") || v.equals("FLOAT") ? "FLOAT" : "INT";
                } else {
                    Symbol op_symbol = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1));
                    parser.reportarErrorSemantico("Operacion de multiplicacion invalida entre los tipos " + t1 + " y " + v, op_symbol);
                    RESULT = "error_tipo";
                }
            :}
          | termino OPERADOR_DIVISION valor
            {:
                String t1 = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
                String v = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
                if ((t1.equals("INT") || t1.equals("FLOAT")) && (v.equals("INT") || v.equals("FLOAT"))) {
                    RESULT = "FLOAT";
                } else {
                    Symbol op_symbol = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1));
                    parser.reportarErrorSemantico("Operacion de division invalida entre los tipos " + t1 + " y " + v, op_symbol);
                    RESULT = "error_tipo";
                }
            :}
          | valor:v
            {: RESULT = v; :}
          ;

valor::= VALOR_ENTERO {: RESULT = "INT"; :}
       | VALOR_FLOTANTE {: RESULT = "FLOAT"; :}
       | VALOR_CADENA {: RESULT = "STRING"; :}
       | TRUE {: RESULT = "BOOL"; :}
       | FALSE {: RESULT = "BOOL"; :}
       | IDENTIFICADOR
       {:
           Symbol id_sym = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek());
           Simbolo s = parser.tablaSimbolos.buscar(id_sym.value.toString());
           if (s == null) {
               parser.reportarErrorSemantico("Identificador '" + id_sym.value + "' no ha sido declarado", id_sym);
               RESULT = "error_tipo";
           } else {
               RESULT = s.tipo;
           }
       :}
       | PAREN_APERTURA expresion:e PAREN_CIERRE {: RESULT = e; :}
       ;

tipo_dato::= BOOL {: RESULT = "BOOL"; :} | BYTE {: RESULT = "BYTE"; :} | CHAR {: RESULT = "CHAR"; :}
           | DECIMAL {: RESULT = "DECIMAL"; :} | DOUBLE {: RESULT = "DOUBLE"; :} | FLOAT {: RESULT = "FLOAT"; :}
           | INT {: RESULT = "INT"; :} | LONG {: RESULT = "LONG"; :} | OBJECT {: RESULT = "OBJECT"; :}
           | SBYTE {: RESULT = "SBYTE"; :} | SHORT {: RESULT = "SHORT"; :} | STRING {: RESULT = "STRING"; :}
           | UINT {: RESULT = "UINT"; :} | ULONG {: RESULT = "ULONG"; :} | USHORT {: RESULT = "USHORT"; :}
           | VOID {: RESULT = "VOID"; :}
           ;

declaracion_metodo::= tipo_dato IDENTIFICADOR PAREN_APERTURA PAREN_CIERRE
                   {:
                       String t = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
                       Symbol id_symbol = (Symbol) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2));
                       parser.tablaSimbolos.insertar(id_symbol.value.toString(), t, id_symbol.left, id_symbol.right);
                       parser.tablaSimbolos.entrarAlcance(); 
                   :}
                   LLAVE_APERTURA sentencias LLAVE_CIERRE
                   {: parser.tablaSimbolos.salirAlcance(); :}
                   ;

sentencia_if::= IF PAREN_APERTURA expresion PAREN_CIERRE
               {: parser.tablaSimbolos.entrarAlcance(); :}
               LLAVE_APERTURA sentencias LLAVE_CIERRE
               {: parser.tablaSimbolos.salirAlcance(); :}
               ;

sentencia_while::= WHILE PAREN_APERTURA expresion PAREN_CIERRE
                  {: parser.tablaSimbolos.entrarAlcance(); :}
                  LLAVE_APERTURA sentencias LLAVE_CIERRE
                  {: parser.tablaSimbolos.salirAlcance(); :}
                  ;
                  
sentencia_do::= DO {: parser.tablaSimbolos.entrarAlcance(); :} LLAVE_APERTURA sentencias LLAVE_CIERRE {: parser.tablaSimbolos.salirAlcance(); :} WHILE PAREN_APERTURA expresion PAREN_CIERRE PUNTO_COMA;

sentencia_for::= FOR PAREN_APERTURA dec_var_item PUNTO_COMA expresion PUNTO_COMA dec_var_item PAREN_CIERRE
                {: parser.tablaSimbolos.entrarAlcance(); :}
                LLAVE_APERTURA sentencias LLAVE_CIERRE
                {: parser.tablaSimbolos.salirAlcance(); :}
                ;

sentencia_switch::= SWITCH PAREN_APERTURA expresion PAREN_CIERRE
                   {: System.out.println("Sentencia Switch reconocida (sin analisis semantico aun)"); :}
                   LLAVE_APERTURA LLAVE_CIERRE
                   ;